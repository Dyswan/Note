# C++ 类
<!-- TOC -->

- [C++ 类](#c-类)
    - [构造函数](#构造函数)
    - [class和struct关键字](#class和struct关键字)
    - [封装的益处](#封装的益处)
    - [从const成员函数中返回*this](#从const成员函数中返回this)
    - [基于const的重载](#基于const的重载)
    - [隐式的类类型转换](#隐式的类类型转换)
        - [只允许一步类类型转换：](#只允许一步类类型转换)
        - [抑制构造函数的隐式转换：](#抑制构造函数的隐式转换)
        - [explicit构造函数只能用于初始化：](#explicit构造函数只能用于初始化)
        - [为了转化显式地使用构造函数：](#为了转化显式地使用构造函数)
    - [字面值常量类](#字面值常量类)
        - [constexpr构造函数](#constexpr构造函数)
    - [类的静态成员](#类的静态成员)
        - [声明静态成员](#声明静态成员)
        - [定义静态成员](#定义静态成员)
        - [静态成员的类内初始化](#静态成员的类内初始化)
        - [静态成员的独特操作](#静态成员的独特操作)

<!-- /TOC -->

---
## 构造函数
在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 **=default** 来要求编译器生成构造函数。如果dault在类内部，则默认构造函数时内联的；如果它在类的外部，则该成员默认状态下不是内联的。

---
## class和struct关键字

class和struct其实都可以定义任何一个类，唯一的区别时struct和class的默认访问权限不一样。如果使用struct关键字，第一个访问说明符之前的成员是public的，相反，如果使用class，第一个访问说明符之前的成员是private的。

---
## 封装的益处
主要有两个优点：
- 确保用户代码不会无意间破坏破坏封装对象的状态。
- 被封装的类的具体实现细节可以随意改变，而无需调整用户级别的代码。

---
## 从const成员函数中返回*this
一个const成员函数，中this是一个指向const的指针而*this则是一个const对象。因此，如果要从const函数中返回*this返回的应该const对象。

---
## 基于const的重载
通过区分成员函数const与否，我们可以对其进行重载。总的来说，如果是常量对象的话就会调用const的重载成员函数，如果是非常量对象则调用非常量成员函数，因为在const成员函数默认是const *this。<br>
同理，如果非常量成员函数中调用了const成员函数，*this在该const成员函数也会转化成const *this。

---
## 隐式的类类型转换
如果类的构造函数**只接受一个实参**，则它实际上定义了转换为此类类型的隐式转换机制，这个称为**转换构造函数**。
```cpp
class A{
public:
    A(string s):str(s){};//只接受一个实参的构造函数
private:
    string str;
}
string b="123";
A a=b; //隐式转换
```

### 只允许一步类类型转换：
类类型能定义由编译器自动执行的转换，不过编译器每次只执行一种类类型转换。
```cpp
A a="123";//错误，因为从“123”->string->A超过两步
A a=string("123");//正确
```

### 抑制构造函数的隐式转换：
在要求隐式转换的程序上下文中，我们可以通过构造函数声明为**explicit**加以阻止,并且只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复：
```cpp
class A{
public:
    explicit A(string s):str(s){};//只接受一个实参的构造函数
private:
    string str;
}

```


### explicit构造函数只能用于初始化：
当我们使用explicit关键字声明构造函数的时候，它将只能以直接初始化的形式使用。并且，编译器井不会在自动转换过程中使用该构造函数。<br>

### 为了转化显式地使用构造函数：
尽管编译器不会将explicit的构造函数用于隐式转换，但我们却可以使用这样的构造函数显式地强制转换：
```cpp
A b = static_cast<A>("123");//正确，static_cast可以使用explicit构造函数
```
static_cast使用A(string )构造函数创建了临时的A对象

---
## 字面值常量类
数据成员全是字面值类型的聚合类是字面值常量类。如果不是聚合类，但满足以下条件也是字面值常量类：
- 数据成员都必须是字面值类型
- 类必须至少包含一个constexpr构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，其初始值构造函数必须使用成员自己的constexpr构造函数。
- 类必须使用析构函数的默认定义，该成员负责销毁对象

### constexpr构造函数
constexpr构造函数可以声明成default的形式或是删除函数的形式。<br>
否则，constexpr构造函数必须既符合构造函数要求，又符合constexpr函数的要求。只要前置关键字constexpr就可以声明好了。
不过要注意的是:
- constexpr构造函数必须初始化所有数据成员，初始值或是使用consexpr构造函数，或是一条常量表达式。
- cosntexpr构造函数用于生辰constexpr对象以及constexpr函数的参数或返回类型。

---
## 类的静态成员

### 声明静态成员
通过在成员声明之前加上关键字static使得其与类关联在一起。
类的静态成员存在于任何对象之外，对象不包含任何与静态成员有关的数据。同样的，静态成员函数也不会与任何对象绑定在一起，因此他们不包含this指针。静态成员函数也不能声明成const。

### 定义静态成员
和其他成员函数一样，我们既可以在类内部也可以在内外部**定义**静态成员函数。但在类外部定义静态成员时，不能重复static关键字，该关键字只能出现在**类内部的声明语句**。
因为静态数据成员不属于任何一个对象，所以它们并不是在创建对象时被定义的。因此，**静态数据成员并不是由类的构造函数初始化的**。我们不能在类的内部定义初始化静态成员。相反，必须在类的外部**定义和初始化**所有静态成员，并且一个只能定义一次。

### 静态成员的类内初始化
我们可以为静态成员提供const整数类型的类内初始，不过要求静态成员必须是字面值常量或constexpr。
如果在类内提供了一个初始值，那成员的定义不能再指定一个初始值了。不过即使是这样，也应该在类外定义以下该成员。

### 静态成员的独特操作
- 静态成员可以是它所属类的类型
- 静态成员可以作为默认实参
