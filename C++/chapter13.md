# C++拷贝控制
<!-- TOC -->

- [C++拷贝控制](#c拷贝控制)
    - [拷贝、赋值和销毁](#拷贝赋值和销毁)
        - [拷贝构造函数](#拷贝构造函数)
        - [拷贝初始化](#拷贝初始化)
        - [什么时候调用析构函数](#什么时候调用析构函数)
        - [三/五法则](#三五法则)
    - [阻止拷贝](#阻止拷贝)
        - [定义删除的函数](#定义删除的函数)
        - [析构函数不能是删除的成员](#析构函数不能是删除的成员)
        - [合成的拷贝控制成员可是是删除的](#合成的拷贝控制成员可是是删除的)
    - [拷贝控制与资源管理](#拷贝控制与资源管理)
        - [行为像值的类](#行为像值的类)
            - [类值拷贝赋值运算符](#类值拷贝赋值运算符)
        - [行为像指针的类](#行为像指针的类)
            - [引用计数](#引用计数)
    - [对象移动](#对象移动)
        - [右值引用](#右值引用)
            - [标准库move函数](#标准库move函数)
        - [右值和左值引用成员函数](#右值和左值引用成员函数)

<!-- /TOC -->

---
## 拷贝、赋值和销毁

### 拷贝构造函数
如果一个构造函数的第一个参数是对自身类型的引用，且任何额外参数都有默认值，则此构造函数是**拷贝构造函数**。拷贝构造函数在几种情况下会被隐式地使用，因此，拷贝构造函数通常不应该是explicit的。

### 拷贝初始化
现在我们要理解直接初始化和拷贝初始化之间的差异。
```cpp
string dots(10,',');//直接初始化
string s(dots);//直接初始化
string s2 = dots;//拷贝初始化
string x = "123";//拷贝初始化
string y=string(10,'1');//拷贝初始化
```
**直接初始化**：编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。<br>
**拷贝初始化**：编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。<br>
拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的。<br>
拷贝初始化不仅在我们用=定义变量时发生，在下列情况也会发生：

- 将对象作为实参传递给非引用类型的形参

- 从一个返回类型为非引用的函数中返回一个对象

- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

### 什么时候调用析构函数
无论何时一个对象被销毁，就会自动调用其析构函数：
- 变量离开其作用域时会被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（无论是标准容器还是内置数组）被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
- 对于临时对象，当它创建的完整表达式结束时被销毁

### 三/五法则
- 需要析构函数的类也要需要拷贝和赋值操作

- 需要拷贝操作的类也需要赋值操作，反之亦然

---
## 阻止拷贝
对于某些类来说定义拷贝构造函数和拷贝赋值函数没有合理的意义，在这种情况下定义类时必须采用某种机制阻止拷贝或赋值。

### 定义删除的函数
新标准下可以把拷贝构造函数和拷贝赋值函数定义为**删除的函数**来阻止拷贝。**删除函数**：在函数参数列表后面加上=delete，表示我虽然声明了它们，但不能以任何形式使用它们。
```cpp
struct node{
    node()=default;
    node(const node&)=delete; //阻止拷贝
    node &operator=(const node&)=delete; //阻止赋值
}
```
=delete会通知编译器，我们不希望定义这些成员。不过与=default不同的是，可以对任何函数指定=delete（我们只能对编译器可以合成的默认够好函数或拷贝控制成员使用=default）。

### 析构函数不能是删除的成员
不能删除析构函数。对于一个删除了析构函数的对象，编译器将不允许定义该类型的的对象或创建该类的临时对象。

### 合成的拷贝控制成员可是是删除的
本质上，当不可拷贝、赋值或销毁类的成员的时候，类的对应的合成拷贝控制成员就被定义为是删除了。
- 如果类的某个成员的**析构函数**是删除的或不可访问的（例如private），则类的**合成析构函数和合成拷贝构造函数**被定义为删除的

- 如果类的某个成员的**拷贝构造函数**是删除的或不可访问的（例如private），则类的**合成拷贝构造函数**被定义为删除的

- 如果类的某个成员的**拷贝赋值函数**是删除的或不可访问的（例如private），或是类有一个const的或引用成员，则类的**合成拷贝赋值函数**被定义为删除的

- 如果类的某个成员的**析构函数**是删除的或不可访问的（例如private），或是类有一个引用成员，它没有类内初始化器，或是类有const成员，它没有类内初始化器且其类型为显式定义默认构造函数，则类的**默认构造函数函数**被定义为删除的

---
## 拷贝控制与资源管理
### 行为像值的类
为了实现类值行为，需要：
- 定义一个拷贝构造函数
- 定义一个析构函数
- 定义一个拷贝赋值运算符释放当前成员，并从右侧运算对象拷贝

#### 类值拷贝赋值运算符
赋值运算符通常组合了析构函数和构造函数的操作。当编写赋值运算符时，要记住两点：
- 如果将一个对象赋予它本身，赋值运算符必须能正常工作。
- 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。

一个好的模式是先将右侧运算对象拷贝到一个局部临时变量中。拷贝完成后销毁左侧运算对象的现有成员就是安全了。一旦左侧运算符中对象被销毁，就只剩将数据从临时对象拷贝到左侧运算对象的成员中了。

### 行为像指针的类
对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值函数，来拷贝指针，并且需要自己的析构函数来释放分配的内存。
当然，另一个类展现类似行为的最好方法就是使用shared_ptr来管理类中的资源。但有时我们会想直接管理资源。在这种情况下，使用**引用计数**就很有用了。<br>
#### 引用计数
先看看引用计数的工作方式：
![1](https://img-blog.csdnimg.cn/20200303170143140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg1OTcxNg==,size_16,color_FFFFFF,t_70)
现在问题在于应该在拿存放引用计数，因为引用计数并不能直接作为对象的成员。<br>
一种解决方法是将计数器保存在动态内存中。当创建对象时，我们分配一个新的计数器。拷贝或赋值时就拷贝指向计数器的指针即可。

---
## 对象移动
### 右值引用
**右值引用**就是必须要绑定到右值的引用。我们通过使用&&而不是&来获得右值引用。一般而言，一个左值表达式表示的是一个对象的身份，一个右值表达式表示的是对象的值。<br>
右值引用有一个重要的性质：只能绑定到一个将要销毁的对象。
#### 标准库move函数
虽然不能将右值引用直接绑定在一个左值上。，但我们可以显式地将一个左值转换为对应的右值引用。我们还可以通过move函数来获得绑定到左值上的右值引用（此函数在头文件utility中）
```cpp
int &&rr1 = 42;
int &&rr2 = std::move(rr1);
```
move告诉编译器：我有一个左值，但我们希望像右值一样处理它。调用move意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。

### 右值和左值引用成员函数
我们可以通过在参数列表后防止**引用限定符**来指出this指针的左值/右值属性。引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。对于&限定的函数，我们只能将它用于左值。对于&&限定的函数，我们只能将它用于右值。
