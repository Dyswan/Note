# C++ 函数
<!-- TOC -->

- [C++ 函数](#c-函数)
    - [分离式编译](#分离式编译)
    - [main：处理命令行选项](#main处理命令行选项)
    - [含可变形参的函数](#含可变形参的函数)
        - [initializer_list形参](#initializer_list形参)
        - [可变参数模板](#可变参数模板)
        - [省略符形参](#省略符形参)
    - [constexpr函数](#constexpr函数)
    - [调试帮助](#调试帮助)
        - [assert](#assert)
        - [NDEBUG预处理变量](#ndebug预处理变量)
    - [函数匹配](#函数匹配)
        - [函数匹配步骤](#函数匹配步骤)
        - [实参类型转换](#实参类型转换)
    - [尾置返回类型](#尾置返回类型)

<!-- /TOC -->

---
## 分离式编译
C++支持**分离式编译**，所谓的分离式编译就是允许把文件分割到几个文件中去，每个文件独立编译。

---
## main：处理命令行选项
有时我们需要给main传递实参，一种常见的情况是用户设置一组选项来确定函数所要执行的操作。例如，main函数位于prog文件内，我们可以向程序传递以下的选项：
```
prog -d -o ofile data0
```
这些命令行选项通过两个（可选的）形参传递给main函数：
```cpp
int main(int argc,char *argv[]){ ... }
```
其中第二个形参argv是一个数组，里面存的是c风格的字符串的指针，第一个形参则是数组中字符串的数量。当实参传给main函数之后，argv的第一个元素指向程序的名字或一个空字符串，接下来就依次传递命令行提供的实参，最后一个指针的元素值保证为0。以上面的命令行为例：
```cpp
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```
*注意：使用argv中的实参的时候，一定要从argv[1]开始，因为argv[0]保存的是程序的名字而不是用户输入。*

---
## 含可变形参的函数
为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法。如果所有实参类型相同，可以传递一个名为**initializer_list的标准库类型**；如果不同可以提供**可变参数模板**。C++还有一种特殊的形参就是**省略符形参**，一般用于与c函数交互的接口程序。
### initializer_list形参
```cpp
initializer_list<T> li;//默认初始化：T类型的空列表
initializer_list<T> li{a,b,c..};
```
### 可变参数模板
之后加
### 省略符形参
之后加

---
## constexpr函数
constexpr函数指能用于常量表达式的函数，不过要遵循几项约定：
- 函数的返回值类型以及所有的形参类型都是字面值类型
- 函数体中有且只有一个return语句

执行初始化任务时，编译器会把constexpr函数的调用c替换成其结值。为了在编译过程中随时展开，constexpr被隐式地指定为内联(inline)函数。

---
## 调试帮助

### assert
assert使用一个表达式作为他的条件：assert(*expr*);<br>
先对expr求值，如果表达式为假，assert输出信息并终止程序。如果表达式为真，assert就什么都不干。

### NDEBUG预处理变量
asssert的行为依赖于NDEBUG这个预处理遍历的状态。如果定义了NDEBUG则assert什么也不做，默认状态下没有定义NDEBUG，此时，assert在将运行时检查。当然，处了assert我们也可以在自己的代码变现条件调试代码方便调试。

---
## 函数匹配
### 函数匹配步骤
1. 确定候选函数
    - 与被调用函数同名
    - 声明在调用点可见

2. 确定可行函数
    - 形参数量与本次调用的实参数量相等
    - 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。

3. 寻找最佳匹配（如果由的话）

    基本思想：实参类型与形参类型越接近，匹配的越好。<br>
    如果有且仅有一个函数满足以下条件，则匹配成功：
    - 该函数每个实参的匹配都不劣与其他可行函数需要的匹配（即每一项都>=）
    - 至少有一个实参的匹配优于其他可行函数提供的匹配（存在一项>）

### 实参类型转换

编译器将实参类型到成形参类型的转换分几个等级，具体排序如下：
1. 精确匹配，包含如下情况：

    - 实参类型和形参类型相同
    - 实参从数组类型或从函数类型转换成对应的指针
    - 向实参添加顶层const或从实参删除底层const

2. 通过const转换实现匹配
3. 通过类型提升实现的匹配
4. 通过算术类型转换或指针转换
5. 通过类类型转换实现的匹配

---
## 尾置返回类型
C++11新标准中提供了尾置返回类型，这种形式对于复杂的函数很有效。<br>
尾置返回类型在参数列表后以->开头。为了表示函数真正的返回类型跟在形参列表之后，我们在原本应该出现返回类型的位置放一个auto。
```cpp
auto fun(int x)->int(*)[10];
``` 